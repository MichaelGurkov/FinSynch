---
title: ""
author: "Michael Gurkov"
output: "html_document"     

vignette: >
  %\VignetteIndexEntry{CycleSynch}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,echo = FALSE,
  message = FALSE,warning = FALSE,
  comment = "#>"
)
```


```{r load_package}

devtools::load_all()

library(MiscImport)

library(lubridate)

library(tidyverse)

library(tidymodels)

library(tidyselect)

library(plm)

library(hdm)

library(stargazer)
 
library(scales)

library(glue)

```


```{r import_data}

df = read_rds("C:\\Users\\Home\\Desktop\\synch.rds")

df = df %>% 
  mutate(synch = 100 * synch)

```


```{r child="Import_Data.Rmd", eval=FALSE}

```

# Introduction

I replicate the paper "Financial Regulation, Financial Globalization, and the Synchronization of Economic Activity" (Journal of Finance, 2013) \footnote{Part of the paper's data is confidential so the replication is not complete}. The paper studies the relationship between synchronization of business cycles and  financial integration. 

The theory provides ambiguous predictions regarding the effect of financial integration on business cycles synchronization. On the one hand, financial integration can help diversify risk, redirect capital to more profitable investment opportunities and act as country-specific "shock absorber". On the other hand, banking integration can induce contagion effects and act as a global "shock propagator". In that case, a positive association should be observed. The authors find that output synchronization is negatively affected by financial integration. The authors explain the connection as follows: if a country is hit with a negative productivity shock, global banks will reduce credit to that country and increase credit to another country, thus, exacerbating negative output effect in the former country and facilitating positive output effect in the latter. In order to establish causal relatioship the paper uses
instrumental variable technique.

# OLS estimation - replication of the main result

```{r ols}


x_vars = "bank_int"

ols_mod_within = plm(
  formula = formula("synch ~ bank_int"),
  model = "within",
  effect = "twoways",
  index = c("countrypair", "date"),
  data = df)


ols_mod_between = plm(
  formula = formula("synch ~ bank_int"),
  model = "between",
  effect = "time",
  index = c("countrypair", "date"),
  data = df)

```


```{r results='asis'}

data.frame(model_spec = c("between","within"),
       coeff = c(coefficients(ols_mod_between)[2],
                 coefficients(ols_mod_within))) %>% 
  stargazer(type = "html",summary = FALSE)

```



# IV estimation

In order to establish causality the authors employ instrumental variable - they use the transposition of EU directives into national law. The variation in the time that takes each country to transpose the directives into law is the proxy to financial integration.
 
```{r iv, eval=FALSE}

# x_vars = names(df)[!names(df) %in% c("synch","fsap_ind")] %>%
#   glue_collapse(sep = "+")
# 
# iv_vars = names(df)[!names(df) %in% c("synch","bank_int")] %>% 
#   glue_collapse(sep = "+")


x_vars = "bank_int + trade + fx_regime"

iv_vars = "fsap_ind + trade + fx_regime"

iv_mod = plm(
  formula = glue("synch ~ ", x_vars, "|", iv_vars),
  model = "within",
  effect = "twoways",
  index = c("countrypair", "date"),
  data = df
)



```


# Lasso estimation

In this section I try the double and partial lasso methods in order to
compare them to IV estimation.

```{r partial_lasso, eval=FALSE}

part_Lasso = rlassoEffect(x = x_mat,
                          y = y,
                          d = d,
                          method = "partialling out")

double_Lasso = rlassoEffect(x = x_mat,
                          y = y,
                          d = d,
                          method = "double selection")


```

# Forecasting

```{r data_split}

data_split = initial_split(df)

train_set = training(data_split)

test_set = testing(data_split)

```


```{r models_specs}

lasso_spec = linear_reg(penalty = tune()) %>% 
  set_mode("regression")  %>% 
  set_engine("glmnet")

rf_spec <- 
   rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %>% 
   set_engine("ranger") %>% 
   set_mode("regression")

xgb_spec <- 
   boost_tree(tree_depth = tune(), learn_rate = tune(), loss_reduction = tune(), 
              min_n = tune(), sample_size = tune(), trees = tune()) %>% 
   set_engine("xgboost") %>% 
   set_mode("regression")


```


```{r workflows}

wf_set = workflow_set(
  preproc = list(rec = pre_recipe),
  models = list(lasso = lasso_spec, rf = rf_spec, xgb = xgb_spec)
)

wf_res = wf_set %>%
  workflow_map(
    fn = "tune_grid",
    resamples = vfold_cv(train_set),
    grid = 10,
    verbose = TRUE
  )


```


```{r model_fit}


pre_recipe = recipe(synch ~ ., data = train_set) %>% 
  step_rm("fsap_ind") %>% 
  step_mutate(date = factor(date)) %>% 
  step_dummy(c("countrypair", "date"))

lasso_wf = workflow() %>% 
  add_recipe(pre_recipe) %>% 
  add_model(lasso_mod)
  
lasso_fit = lasso_wf %>% 
  tune_grid(resamples = vfold_cv(train_set),
            grid = grid_regular(penalty(), levels = 10))

final_fit = lasso_wf %>% 
  finalize_workflow(lasso_fit %>% 
  select_best(metric = "rmse"))

```


```{r evaluation}

fit_res = last_fit(final_fit, data_split)
  
lasso_rmse = fit_res %>% 
  collect_metrics() %>% 
  filter(.metric == "rmse") %>% 
  pull(.estimate)


```

In this section I forecast the dependent variable using lasso
